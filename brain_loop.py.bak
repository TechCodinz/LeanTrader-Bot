# brain_loop.py
# Orchestrates: scan → enrich/score → plan(size/targets) → (optional trade) → publish → remember

from __future__ import annotations

import json
import os
import random
import threading
import time
import traceback
from dataclasses import dataclass
from datetime import datetime  # noqa: F401
from typing import Any, Dict, List, Optional

import numpy as np  # Added for ML arrays

# ---- dependencies in your repo ----
import signals_scanner as scanner
from pattern_memory import FEATS, features, get_score, recall, record
from signals_publisher import publish_batch

# session-weighted sizing/targets (+ optional OCO helpers)
try:
    from risk_engine import equity_from_router  # if you have it
except Exception:
    equity_from_router = None

try:
    from trade_planner import attach_plan, place_oco_ccxt_safe
except Exception:

    def attach_plan(sig: Dict[str, Any], equity: float) -> Dict[str, Any]:
        return sig

    def place_oco_ccxt_safe(*a, **k):
        pass


# Router for CCXT autotrade
try:
    from router import ExchangeRouter
except Exception:
    ExchangeRouter = None  # graceful offline

# ---- Telegram (optional) ----
try:
    from tg_utils import send_text  # def send_text(msg:str)->bool
    from tg_utils import heartbeat
except Exception:

    def send_text(_: str) -> None:  # no-op if unavailable
        pass

    def heartbeat(_: list) -> None:
        return None


# New imports for enhancements
try:
    import xgboost as xgb  # For ML-based confidence blending

    xgb_model = xgb.XGBRegressor()
except ImportError:
    xgb_model = None

try:
    from news_bias import news_bias  # Assuming this exists or fallback
except ImportError:

    def news_bias(symbol, market):
        return {"bias": 0.0, "reason": "stub"}


# =================== ENV HELPERS ===================
def env_b(k: str, d: bool) -> bool:
    return os.getenv(k, str(d)).strip().lower() in ("1", "true", "yes", "y", "on")


def env_f(k: str, d: float) -> float:
    try:
        return float(os.getenv(k, str(d)))
    except:
        return d


def env_i(k: str, d: int) -> int:
    try:
        return int(float(os.getenv(k, str(d))))
    except:
        return d


# =================== CONFIG ===================
THINK_TOP = env_i("THINK_TOP", env_i("TOP_N", 7))
THINK_MIN_CONF = env_f("THINK_MIN_CONF", 0.20)
THINK_EPSILON = env_f("THINK_EPSILON", 0.10)  # exploration prob
THINK_COOLDOWN_SEC = env_i("THINK_SYMBOL_COOLDOWN", 180)
THINK_REPEAT = env_i("THINK_REPEAT", 60)

AUTO_TRADE = env_b("LIVE_AUTOTRADE", False)  # if True, place OCO on CCXT
AUTO_TRADE_MIN_QTY = env_f("AUTOTRADE_MIN_QTY", 0.0)


# =================== SCAN ARGS SHIM ===================
@dataclass
class ScanArgs:
    tf: str = os.getenv("SCAN_TF", "5m")
    top: int = THINK_TOP
    limit: int = env_i("SCAN_LIMIT", 200)
    repeat: int = 0
    publish: bool = False  # scanner never publishes


# =================== ENRICHMENT ===================
def _attach_feats(sig: Dict[str, Any]) -> None:
    if isinstance(sig.get("feats"), dict):
        return
    df = sig.get("df") or sig.get("df_now")
    if df is not None:
        try:
            sig["feats"] = {k: float(features(df).get(k, 0.0)) for k in FEATS}
        except Exception as e:
            # preserve signal but note the failure
            try:
                sig.setdefault("context", []).append(f"feat_err:{e}")
            except Exception:
                pass


def _blend_confidence(sig: Dict[str, Any]) -> float:
    # Enhanced: ML-based blending with XGBoost
    base = float(sig.get("confidence", sig.get("quality", 0.0)) or 0.0)
    prior = get_score(sig)
    if xgb_model and sig.get("feats"):
        try:
            X = np.array(list(sig["feats"].values())).reshape(1, -1)
            ml_pred = xgb_model.predict(X)[0]
            blended = max(0.0, min(1.0, (base + ml_pred) / 2))
        except Exception:
            blended = base
    else:
        # Fallback to existing
        pw = 0.4 if prior.get("n", 0) < 50 else 0.6
        prior_conf = 2.0 * (float(prior.get("winrate", 0.5)) - 0.5)
        try:
            ctx = recall(
                sig["symbol"], sig["tf"], sig.get("df") or sig.get("df_now"), k=200
            )
            prior_conf = max(prior_conf, 2.0 * (ctx.get("winrate", 50.0) / 100.0 - 0.5))
            if ctx.get("note"):
                sig.setdefault("context", []).append(ctx["note"])
        except Exception:
            pass
        blended = max(0.0, min(1.0, (1.0 - pw) * base + pw * prior_conf))
    sig["confidence"] = blended
    sig.setdefault("quality", blended)
    return blended


# =================== NORMALIZE FOR PUBLISHER ===================
def _normalize_for_publisher(sig: Dict[str, Any]) -> Dict[str, Any]:
    out = dict(sig)
    out["market"] = out.get("market") or (
        "fx" if out.get("symbol", "").isalpha() else "crypto"
    )
    out["tf"] = out.get("tf") or os.getenv("SCAN_TF", "5m")
    side = out.get("side") or (
        "buy" if out.get("direction", "long") in ("long", "buy") else "sell"
    )
    out["side"] = side

    px = float(out.get("entry") or out.get("price") or 0.0)
    sl = float(out.get("sl") or out.get("stop") or 0.0)
    out["entry"], out["sl"] = px, sl

    if not all(k in out for k in ("tp1", "tp2", "tp3")):
        R = abs(px - sl) if (px and sl) else max(0.001, abs(px) * 0.003)
        if side == "buy":
            out["tp1"], out["tp2"], out["tp3"] = (
                px + 1.0 * R,
                px + 2.0 * R,
                px + 3.0 * R,
            )
        else:
            out["tp1"], out["tp2"], out["tp3"] = (
                px - 1.0 * R,
                px - 2.0 * R,
                px - 3.0 * R,
            )

    out["confidence"] = float(out.get("confidence", out.get("quality", 0.0)) or 0.0)
    for k in ("entry", "sl", "tp1", "tp2", "tp3", "confidence"):
        try:
            out[k] = float(out[k])
        except:
            out[k] = 0.0
    return out


# =================== COOLDOWN ===================
_last_symbol_ts: Dict[str, float] = {}


def _cooldown_ok(symbol: str, now: float, cd_sec: int) -> bool:
    t = _last_symbol_ts.get(symbol)
    if t is None or now - t >= cd_sec:
        _last_symbol_ts[symbol] = now
        return True
    return False


# =================== AUTOTRADE (CCXT) ===================
_ccxt_router: Optional[ExchangeRouter] = None


def _router() -> Optional[ExchangeRouter]:
    global _ccxt_router
    if _ccxt_router is None and ExchangeRouter is not None:
        try:
            _ccxt_router = ExchangeRouter()
        except Exception:
            _ccxt_router = None
    return _ccxt_router


def _equity_now_fallback(router: Optional[ExchangeRouter]) -> float:
    """Use risk_engine.equity_from_router if available, else do a cheap parse."""
    if equity_from_router and router:
        try:
            return float(equity_from_router(router))
        except Exception:
            pass
    try:
        bal = (router.account().get("balance", {}) if router else {}) or {}
        total = float(
            bal.get("total", {}).get("USDT", 0) or bal.get("total", 0) or 5000
        )
        if total <= 0 and "free" in bal:
            total = float(bal["free"].get("USDT", 0) or 5000)
        return total if total > 0 else 5000.0
    except Exception:
        return 5000.0


def _maybe_autotrade(picks: List[Dict[str, Any]]) -> None:
    # Enhanced: Slippage handling
    if not AUTO_TRADE:
        return
    r = _router()
    if r is None:
        return
    ex = r.ex
    for s in picks:
        try:
            slippage = float(os.getenv("AUTOTRADE_SLIPPAGE", 0.001))
            entry_adj = float(s.get("entry", 0)) * (
                1 + slippage if s["side"] == "buy" else 1 - slippage
            )
            s["entry"] = entry_adj
            if str(s.get("market", "")).lower().startswith("crypto") and float(
                s.get("qty", 0)
            ) > max(0.0, AUTO_TRADE_MIN_QTY):
                place_oco_ccxt_safe(
                    ex,
                    s["symbol"],
                    s["side"],
                    float(s["qty"]),
                    float(s["entry"]),
                    float(s["sl"]),
                    float(s["tp1"]),
                    leverage=s.get("leverage"),
                )
        except Exception as e:
            send_text(f"⚠️ Autotrade error {s.get('symbol')}: {e}")


def _fill_missing_price(
    sig: Dict[str, Any], router: Optional[ExchangeRouter]
) -> Dict[str, Any]:
    """Best-effort: populate missing entry/sl using router tickers or recent OHLCV.

    Writes a debug line to runtime/price_fill_debug.ndjson describing attempts.
    """
    out = dict(sig)
    debug = {
        "symbol": out.get("symbol") or out.get("market"),
        "had_entry": bool(out.get("entry") or out.get("price")),
        "had_sl": bool(out.get("sl") or out.get("stop")),
        "attempts": [],
        "ts": time.time(),
    }
    try:
        entry = float(out.get("entry") or out.get("price") or 0.0)
    except Exception:
        entry = 0.0
    try:
        sl = float(out.get("sl") or out.get("stop") or 0.0)
    except Exception:
        sl = 0.0

    # try ticker last price for entry
    try:
        if entry <= 0.0 and router is not None:
            try:
                tk = (
                    router.safe_fetch_ticker(out.get("symbol") or out.get("market"))
                    or {}
                )
                last = float(tk.get("last") or 0.0)
                if last and last > 0.0:
                    out["entry"] = last
                    debug["attempts"].append({"from": "ticker", "last": last})
            except Exception as e:
                debug["attempts"].append({"ticker_err": str(e)})

        # if sl missing, try a conservative SL from recent ohlcv
        if sl <= 0.0 and router is not None:
            try:
                ohlcv = (
                    router.safe_fetch_ohlcv(
                        out.get("symbol") or out.get("market"),
                        timeframe=out.get("tf", "5m"),
                        limit=20,
                    )
                    or []
                )
                if ohlcv:
                    lows = [
                        float(x[3])
                        for x in ohlcv
                        if isinstance(x, (list, tuple)) and len(x) > 3
                    ]
                    highs = [
                        float(x[2])
                        for x in ohlcv
                        if isinstance(x, (list, tuple)) and len(x) > 2
                    ]
                    last_px = (
                        float(ohlcv[-1][4]) if ohlcv and len(ohlcv[-1]) > 4 else 0.0
                    )
                    side = out.get("side") or (
                        "buy"
                        if out.get("direction", "long") in ("long", "buy")
                        else "sell"
                    )
                    if lows and highs:
                        if side == "buy":
                            slv = float(min(lows))
                        else:
                            slv = float(max(highs))
                        out["sl"] = slv
                        debug["attempts"].append(
                            {"from": "ohlcv", "sl": slv, "last": last_px}
                        )
            except Exception as e:
                debug["attempts"].append({"ohlcv_err": str(e)})
    except Exception as e:
        debug["error"] = str(e)

    # persist debug line (best-effort)
    try:
        os.makedirs("runtime", exist_ok=True)
        p = os.path.join("runtime", "price_fill_debug.ndjson")
        with open(p, "a", encoding="utf-8") as fh:
            fh.write(json.dumps(debug, default=str) + "\n")
    except Exception:
        pass

    return out


# =================== ONE THINK CYCLE ===================
def think_once() -> List[Dict[str, Any]]:
    raw = scanner.run_once(ScanArgs())
    if not raw:
        return []

    # Enhanced: Parallel enrichment with threading
    enriched = []
    lock = threading.Lock()

    def enrich_worker(s):
        try:
            _attach_feats(s)
            if s.get("confidence") is None:
                s["confidence"] = s.get("quality", 0.0)
            c = _blend_confidence(s)
            if c >= THINK_MIN_CONF and _cooldown_ok(
                s["symbol"], time.time(), THINK_COOLDOWN_SEC
            ):
                with lock:
                    enriched.append(s)
        except Exception as e:
            try:
                send_text(f"[think_once] enrich error {s.get('symbol')}: {e}")
            except Exception:
                pass

    threads = [threading.Thread(target=enrich_worker, args=(s,)) for s in raw]
    for t in threads:
        t.start()
    for t in threads:
        t.join()
    if not enriched:
        return []

    # Optional multi-timeframe/session spotting (module-level helper)
    try:
        enriched = multi_timeframe_session_spotting(enriched)
    except Exception:
        pass

    enriched.sort(
        key=lambda z: float(z.get("confidence", z.get("quality", 0.0))), reverse=True
    )
    picks: List[Dict[str, Any]] = []
    for s in enriched:
        if len(picks) >= THINK_TOP:
            break
        picks.append(
            s if random.random() >= THINK_EPSILON else s
        )  # hook for diversification

    # plan (sizing/targets) -> optional autotrade -> normalize for publisher
    router = _router()
    eq = _equity_now_fallback(router)
    planned: List[Dict[str, Any]] = []
    for s in picks:
        try:
            if env_b("THINK_FILL_MISSING_PRICE", False):
                try:
                    s = _fill_missing_price(s, router)
                except Exception:
                    pass
            p = attach_plan(s, eq)
            planned.append(p)
        except Exception as e:
            try:
                send_text(f"[think_once] attach_plan error {s.get('symbol')}: {e}")
            except Exception:
                pass
            continue

    # memory snapshot (if df present)
    for s in planned:
        try:
            df = s.get("df")
            if df is not None:
                record(
                    s["symbol"],
                    s.get("tf") or os.getenv("SCAN_TF", "5m"),
                    df,
                    float(s["entry"]),
                    meta={
                        "side": s["side"],
                        "market": s.get("market", "?"),
                        "conf": float(s.get("confidence", 0.0)),
                    },
                )
        except Exception:
            pass

    # optional live autotrade (CCXT, with OCO)
    if AUTO_TRADE and planned:
        try:
            _maybe_autotrade(planned)
        except Exception as e:
            try:
                send_text(f"[think_once] autotrade error: {e}")
            except Exception:
                pass

    # normalize signals before publishing
    normalized = []
    for s in planned:
        try:
            try:
                from news_bias import news_bias

                nb = news_bias(s.get("symbol"), s.get("market"))
                bias = float(nb.get("bias", 0.0))
                if bias:
                    s["confidence"] = float(
                        s.get("confidence", s.get("quality", 0.0))
                    ) * (1.0 + 0.1 * bias)
                    s.setdefault("context", []).append(
                        f"news_bias:{nb.get('reason','')}"
                    )
            except Exception:
                pass
            normalized.append(_normalize_for_publisher(s))
        except Exception as e:
            try:
                send_text(f"[think_once] normalize error {s.get('symbol')}: {e}")
            except Exception:
                pass
            continue

    # filter out obviously non-executable plans (missing entry or zero qty)
    filtered = []
    for s in normalized:
        try:
            if float(s.get("entry", 0.0)) <= 0.0 or float(s.get("qty", 0.0)) <= 0.0:
                s.setdefault("context", []).append("filtered:missing_entry_or_qty")
                continue
        except Exception:
            continue
        filtered.append(s)

    # Enhanced: Log demo trades
    for s in filtered:
        print(f"[DEMO] Signal: {s['symbol']} {s['side']} at {s.get('entry', 0)}")

    # publish (Telegram/webhook/queue handled by publisher)
    if filtered:
        try:
            publish_batch(filtered)
        except Exception:
            pass

    # notify via Telegram (safe module-level helper)
    if filtered:
        try:
            beautiful_telegram_notification(filtered)
        except Exception:
            pass

    return filtered


def beautiful_telegram_notification(signals: List[Dict[str, Any]]):
    """Safe, module-level pretty Telegram notifications with emoji + graceful fallback."""
    try:
        from tg_utils import send_text as tg_send
    except Exception:
        return
    for sig in signals:
        try:
            emoji = "🚀" if str(sig.get("side", "")).lower() == "buy" else "📉"
            msg = f"{emoji} {sig.get('symbol','?')} {str(sig.get('side','?')).upper()} | Conf: {float(sig.get('confidence',0)):.2f} | TF: {sig.get('tf','?')}\n"
            msg += f"Entry: {float(sig.get('entry',0)):.6f} | SL: {float(sig.get('sl',0)):.6f} | TP: {float(sig.get('tp1',0)):.6f}\n"
            try:
                tg_send(msg)
            except Exception:
                # swallow notifier errors
                pass
        except Exception:
            continue


def multi_timeframe_session_spotting(
    signals: List[Dict[str, Any]],
) -> List[Dict[str, Any]]:
    """Module-level multi-TF expansion (cheap heuristic)."""
    enhanced_signals = []
    for sig in signals or []:
        for tf in ("1m", "5m", "1h"):
            try:
                if _analyze_tf(sig.get("symbol", ""), tf):
                    s = sig.copy()
                    s["tf"] = tf
                    s["session"] = s.get("session", "All")
                    enhanced_signals.append(s)
            except Exception:
                continue
    return enhanced_signals


def _analyze_tf(symbol: str, tf: str) -> bool:
    """Cheap placeholder multi-TF analyzer (stochastic fallback)."""
    try:
        return random.random() > 0.5
    except Exception:
        return False


def profit_summary_notification(trades: List[Dict[str, Any]]):
    """Module-level profit summary via Telegram (safe)."""
    if not trades:
        return
    try:
        from tg_utils import send_text as tg_send
    except Exception:
        return
    total_pnl = sum(float(t.get("pnl", 0) or 0) for t in trades)
    msg = f"💰 Profit Summary: ${total_pnl:.2f} | Trades: {len(trades)}"
    try:
        tg_send(msg)
    except Exception:
        pass


def health_check() -> bool:
    """Simple health check stub (module-level)."""
    try:
        # TODO: add router/ccxt connectivity checks and disk space checks
        return True
    except Exception:
        return False


# =================== LOOP ===================
def main() -> None:
    if THINK_REPEAT <= 0:
        try:
            picks = think_once()
            heartbeat(picks)
        except Exception:
            traceback.print_exc()
        return

    while True:
        try:
            picks = think_once()
            heartbeat(picks)
            if not health_check():
                try:
                    send_text("⚠️ Health Check Failed!")
                except Exception:
                    pass
        except Exception:
            traceback.print_exc()
        time.sleep(THINK_REPEAT)


if __name__ == "__main__":
    main()
